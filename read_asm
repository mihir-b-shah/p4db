
** GO THROUGH THE JUMPS ** 
** GO THROUGH RDTSC() placement, is there reordering? **

How is this read() method used? E.g. in benchmarks/ycsb/txn/read.cpp.
read() returns a future, and the ycsb read method just calls ->get()
on the future.

000000000003b810 <TupleFuture<benchmark::ycsb::YCSBTableInfo::KV>* TransactionBase<benchmark::ycsb::YCSB, benchmark::ycsb::YCSBArgs, benchmark::ycsb::YCSBTableInfo>::read<benchmark::ycsb::YCSBTableInfo::KV>(StructTable<benchmark::ycsb::YCSBTableInfo::KV>*, p4db::key_t)>:
   3b810:	41 57                	push   %r15
   3b812:	41 56                	push   %r14
   3b814:	41 55                	push   %r13
   3b816:	41 54                	push   %r12

/*	remember, x86_64 calling convention is rdi,rsi,rdx,rcx,r8,r9, followed by stack.
	rdi is the this ptr (since this is a member function). rsi is the table ptr,
	rdx is the key. rbx has this, rbp has table, r12 has key. */

   3b818:	49 89 d4             	mov    %rdx,%r12
   3b81b:	55                   	push   %rbp
   3b81c:	48 89 f5             	mov    %rsi,%rbp
   3b81f:	53                   	push   %rbx
   3b820:	48 89 fb             	mov    %rdi,%rbx
   3b823:	48 83 ec 48          	sub    $0x48,%rsp

/*	On Linux, %fs:0x28 holds the stack protector value. So we're moving it into
	the top of the stack frame. We need the intermediate move, since x86 cannot
	do src/dst as memory. */

   3b827:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
   3b82e:	00 00 
   3b830:	48 89 44 24 38       	mov    %rax,0x38(%rsp)

/*	Finding the location of our key, using location() in table/partition.hpp.
	Remember, rdx contained the key. So now it is in %rax. Then, location divides it by
	partition size, which is a field of the table, contained in %rsi. The %rdx:%rax is
	the dividend, we the arg is the divisor, %rax is quotient, %rdx is remainder. Which
	is why we do xor %edx,%edx (since edx op clears rdx). */

   3b835:	48 89 d0             	mov    %rdx,%rax
   3b838:	31 d2                	xor    %edx,%edx
   3b83a:	64 48 8b 0c 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rcx
   3b841:	ff ff 
   3b843:	48 f7 76 48          	divq   0x48(%rsi)
   3b847:	49 89 c6             	mov    %rax,%r14
   3b84a:	41 89 c7             	mov    %eax,%r15d

/*	my_id is in the partition object- that is the ref to 0x60(%rsi). C++ does not define
	default equality operator for structs. In this case, node_t equality devolves to the
	uint32_t operator(), which is masked by 0xff. That is why we do 8-bit test, which sets
	condition codes to %al != 0. The jne is for the loc_info.is_local branch for
	db/transaction.hpp:119. Jump away if not equal.

   3b84d:	33 46 60             	xor    0x60(%rsi),%eax
   3b850:	84 c0                	test   %al,%al
   3b852:	0f 85 b8 01 00 00    	jne    3ba10 <TupleFuture<benchmark::ycsb::YCSBTableInfo::KV>* TransactionBase<benchmark::ycsb::YCSB, benchmark::ycsb::YCSBArgs, benchmark::ycsb::YCSBTableInfo>::read<benchmark::ycsb::YCSBTableInfo::KV>(StructTable<benchmark::ycsb::YCSBTableInfo::KV>*, p4db::key_t)+0x200>

/*	rdtsc writes high 32 bits into %edx, low into %eax, even on x64.
	hence we need shift/or to get the final value. Above we did
	a move from %fs:0xfffffffffffffff8 into %rcx. Small negative offsets
	from %fs are used as thread-local storage, which is how we implement
	the WorkerContext, which stores our per-worker stats. */

   3b858:	0f 31                	rdtsc  
   3b85a:	48 c1 e2 20          	shl    $0x20,%rdx
   3b85e:	48 09 d0             	or     %rdx,%rax
   3b861:	48 89 81 80 01 00 00 	mov    %rax,0x180(%rcx)

/*	Just checks if our mempool of size 8192 (StackPool, defined in db/mempools.hpp,
	has enough "space" (i.e. we don't have more than 8192 futures allocated at any time.
	If not, throw an exception (via the jump to the handler.) */

   3b868:	48 8b 97 a0 01 01 00 	mov    0x101a0(%rdi),%rdx
   3b86f:	48 8d 42 10          	lea    0x10(%rdx),%rax
   3b873:	48 3d 00 20 00 00    	cmp    $0x2000,%rax
   3b879:	0f 87 27 60 fd ff    	ja     118a6 <TupleFuture<benchmark::ycsb::YCSBTableInfo::KV>* TransactionBase<benchmark::ycsb::YCSB, benchmark::ycsb::YCSBArgs, benchmark::ycsb::YCSBTableInfo>::read<benchmark::ycsb::YCSBTableInfo::KV>(StructTable<benchmark::ycsb::YCSBTableInfo::KV>*, p4db::key_t) [clone .cold]>

/*	As seen, mempool.allocate() has been inlined. Note the mempool is allocated
	per txn (b/c we might need multiple futures). On commit/rollback it is freed.
	We allocate using placement-new, which is ostensibly very fast.

	LEA does the computation 0x101a8 + %rdi + %rdx -> %r13. %rdi is the (this) pointer
	for TransactionBase (which holds our memory pools, thread id, undo log, etc). It is
	overridden for each benchmark to be the driver class. The undolog contains ~0x10000
	bytes and occurs before the mempool in the struct member list. As such the 0x101a8 + rdi
	is the base of our mempool array, and then %rdx is our position in stack mempool.
	pxor/movups initialize the 16-byte future (all zeros). Finally we update the pool size. */

   3b87f:	4c 8d ac 17 a8 01 01 	lea    0x101a8(%rdi,%rdx,1),%r13
   3b886:	00 
   3b887:	66 0f ef c0          	pxor   %xmm0,%xmm0
   3b88b:	41 0f 11 45 00       	movups %xmm0,0x0(%r13)
   3b890:	48 89 87 a0 01 01 00 	mov    %rax,0x101a0(%rdi)

/*	Now inlines table->get(). First part, check if our key is within table size range */

   3b897:	48 8b 46 30          	mov    0x30(%rsi),%rax
   3b89b:	49 39 c4             	cmp    %rax,%r12
   3b89e:	0f 83 4c 03 00 00    	jae    3bbf0 <TupleFuture<benchmark::ycsb::YCSBTableInfo::KV>* TransactionBase<benchmark::ycsb::YCSB, benchmark::ycsb::YCSBArgs, benchmark::ycsb::YCSBTableInfo>::read<benchmark::ycsb::YCSBTableInfo::KV>(StructTable<benchmark::ycsb::YCSBTableInfo::KV>*, p4db::key_t)+0x3e0>

/*	Do an address calculation for the Row table. Our key (index) is %r12. Multiply by
	64 (sizeof row), and add the base table offset. The cmp checks the lock_type. We are
	doing a read, so if the lock is held by writer (0x2), we cannot acquire, and jump
	away, else we continue.

   3b8a4:	64 48 8b 0c 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rcx
   3b8ab:	ff ff 
   3b8ad:	4d 89 e6             	mov    %r12,%r14
   3b8b0:	49 c1 e6 06          	shl    $0x6,%r14
   3b8b4:	4c 03 76 70          	add    0x70(%rsi),%r14
   3b8b8:	41 83 7e 28 02       	cmpl   $0x2,0x28(%r14)
   3b8bd:	0f 84 7d 05 00 00    	je     3be40 <TupleFuture<benchmark::ycsb::YCSBTableInfo::KV>* TransactionBase<benchmark::ycsb::YCSB, benchmark::ycsb::YCSBArgs, benchmark::ycsb::YCSBTableInfo>::read<benchmark::ycsb::YCSBTableInfo::KV>(StructTable<benchmark::ycsb::YCSBTableInfo::KV>*, p4db::key_t)+0x630>

/*	Now that we can acquire the lock (for readers, this is just setting lock_type
	to READ, and incrementing the owner_ct, since it's a shared lock). To ensure
	there are no races here, we use a std::mutex to protect this region. We also
	measure contention (on the mutex) via another rdtsc counter- feels like an
	odd measurement of contention though- presumably the first part, checking
	lock_type, should also count as contention? So:
	1) rdtsc start
	2) the cmpq checks if pthread/mutex stuff is initialized.
	3) continued... */

   3b8c3:	0f 31                	rdtsc  
   3b8c5:	48 c1 e2 20          	shl    $0x20,%rdx
   3b8c9:	48 09 d0             	or     %rdx,%rax
   3b8cc:	48 83 3d 9c a6 04 00 	cmpq   $0x0,0x4a69c(%rip)        # 85f70 <__pthread_key_create@GLIBC_2.2.5>
   3b8d3:	00 
   3b8d4:	48 89 81 50 01 00 00 	mov    %rax,0x150(%rcx)
   3b8db:	74 19                	je     3b8f6 <TupleFuture<benchmark::ycsb::YCSBTableInfo::KV>* TransactionBase<benchmark::ycsb::YCSB, benchmark::ycsb::YCSBArgs, benchmark::ycsb::YCSBTableInfo>::read<benchmark::ycsb::YCSBTableInfo::KV>(StructTable<benchmark::ycsb::YCSBTableInfo::KV>*, p4db::key_t)+0xe6>

/*	%r14 holds the row ptr. The mutex is the first member of the row, so it is the same ptr.
	Just pass to pthread_mutex_lock. Lock() returns 0 if acquire succeeds- so jump otherwise. */

   3b8dd:	4c 89 f7             	mov    %r14,%rdi
   3b8e0:	e8 8b 05 fd ff       	callq  be70 <pthread_mutex_lock@plt>
   3b8e5:	85 c0                	test   %eax,%eax
   3b8e7:	0f 85 a2 05 00 00    	jne    3be8f <TupleFuture<benchmark::ycsb::YCSBTableInfo::KV>* TransactionBase<benchmark::ycsb::YCSB, benchmark::ycsb::YCSBArgs, benchmark::ycsb::YCSBTableInfo>::read<benchmark::ycsb::YCSBTableInfo::KV>(StructTable<benchmark::ycsb::YCSBTableInfo::KV>*, p4db::key_t)+0x67f>
   3b8ed:	64 48 8b 0c 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rcx
   3b8f4:	ff ff 

/*	Stop the latch contention measurement via rdtsc. */

   3b8f6:	0f 31                	rdtsc  
   3b8f8:	48 c1 e2 20          	shl    $0x20,%rdx
   3b8fc:	48 09 d0             	or     %rdx,%rax
   3b8ff:	48 03 81 48 01 00 00 	add    0x148(%rcx),%rax
   3b906:	48 2b 81 50 01 00 00 	sub    0x150(%rcx),%rax

/*	Run is_compatible(mode) again- i.e. check if lock_type is still ok for acquire,
	after we acquire the mutex. Note this is a double-checked lock pattern- we check
	before acquiring the mutex (as an early exit), but then check for real once no
	one can change the lock_type. */

   3b90d:	41 83 7e 28 02       	cmpl   $0x2,0x28(%r14)
   3b912:	48 89 81 48 01 00 00 	mov    %rax,0x148(%rcx)
   3b919:	0f 84 31 05 00 00    	je     3be50 <TupleFuture<benchmark::ycsb::YCSBTableInfo::KV>* TransactionBase<benchmark::ycsb::YCSB, benchmark::ycsb::YCSBArgs, benchmark::ycsb::YCSBTableInfo>::read<benchmark::ycsb::YCSBTableInfo::KV>(StructTable<benchmark::ycsb::YCSBTableInfo::KV>*, p4db::key_t)+0x640>

/*	Update the lock_type and owner_ct */

   3b91f:	41 83 46 2c 01       	addl   $0x1,0x2c(%r14)
   3b924:	41 c7 46 28 01 00 00 	movl   $0x1,0x28(%r14)
   3b92b:	00 

/*	Go fetch the TupleFuture, which has an atomic variable with the tuple pointer inside. Go
	set it (since the lock acquisition succeeded). The TLS write is just another counter. */

   3b92c:	4d 8d 7d 08          	lea    0x8(%r13),%r15
   3b930:	49 8d 46 30          	lea    0x30(%r14),%rax
   3b934:	49 87 07             	xchg   %rax,(%r15)
   3b937:	64 48 8b 04 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rax
   3b93e:	ff ff 
   3b940:	48 83 40 18 01       	addq   $0x1,0x18(%rax)

/*	Unlock the mutex. */

   3b945:	48 83 3d 23 a6 04 00 	cmpq   $0x0,0x4a623(%rip)        # 85f70 <__pthread_key_create@GLIBC_2.2.5>
   3b94c:	00 
   3b94d:	74 08                	je     3b957 <TupleFuture<benchmark::ycsb::YCSBTableInfo::KV>* TransactionBase<benchmark::ycsb::YCSB, benchmark::ycsb::YCSBArgs, benchmark::ycsb::YCSBTableInfo>::read<benchmark::ycsb::YCSBTableInfo::KV>(StructTable<benchmark::ycsb::YCSBTableInfo::KV>*, p4db::key_t)+0x147>
   3b94f:	4c 89 f7             	mov    %r14,%rdi
   3b952:	e8 f9 01 fd ff       	callq  bb50 <pthread_mutex_unlock@plt>

/*	Starting log.add_read(). This is an in-memory undolog (just for easy rollback).
	The mov/lea/cmp/ja sequence is identical to previous allocations, to allocate our
	action. The action itself is a virtual object- so there are 4 writes- 3 for the Read
	actions' fields, and the first entry for the vtable ptr- so 4 writes on (%r14).
	The two reads from 0x10...(rbx) are presumably the vector's end ptr and size.
	The add 0x20 increments the pool size, and then if the vector doesn't need to resize,
	we increment the end ptr. 
	*/

   3b957:	48 8b 83 70 01 00 00 	mov    0x170(%rbx),%rax
   3b95e:	48 8d 50 20          	lea    0x20(%rax),%rdx
   3b962:	48 81 fa 00 00 01 00 	cmp    $0x10000,%rdx
   3b969:	0f 87 9b 5f fd ff    	ja     1190a <TupleFuture<benchmark::ycsb::YCSBTableInfo::KV>* TransactionBase<benchmark::ycsb::YCSB, benchmark::ycsb::YCSBArgs, benchmark::ycsb::YCSBTableInfo>::read<benchmark::ycsb::YCSBTableInfo::KV>(StructTable<benchmark::ycsb::YCSBTableInfo::KV>*, p4db::key_t) [clone .cold]+0x64>
   3b96f:	4c 8d b4 03 78 01 00 	lea    0x178(%rbx,%rax,1),%r14
   3b976:	00 
   3b977:	48 8d 05 c2 7f 04 00 	lea    0x47fc2(%rip),%rax        # 83940 <vtable for Read<StructTable<benchmark::ycsb::YCSBTableInfo::KV>, TupleFuture<benchmark::ycsb::YCSBTableInfo::KV> >+0x10>
   3b97e:	49 89 6e 08          	mov    %rbp,0x8(%r14)
   3b982:	48 8b ab 88 01 01 00 	mov    0x10188(%rbx),%rbp
   3b989:	49 89 06             	mov    %rax,(%r14)
   3b98c:	48 8b 83 80 01 01 00 	mov    0x10180(%rbx),%rax
   3b993:	4d 89 66 10          	mov    %r12,0x10(%r14)
   3b997:	4d 89 6e 18          	mov    %r13,0x18(%r14)
   3b99b:	48 83 83 70 01 00 00 	addq   $0x20,0x170(%rbx)
   3b9a2:	20 
   3b9a3:	48 39 e8             	cmp    %rbp,%rax
   3b9a6:	0f 84 d4 02 00 00    	je     3bc80 <TupleFuture<benchmark::ycsb::YCSBTableInfo::KV>* TransactionBase<benchmark::ycsb::YCSB, benchmark::ycsb::YCSBArgs, benchmark::ycsb::YCSBTableInfo>::read<benchmark::ycsb::YCSBTableInfo::KV>(StructTable<benchmark::ycsb::YCSBTableInfo::KV>*, p4db::key_t)+0x470>
   3b9ac:	48 83 c0 08          	add    $0x8,%rax
   3b9b0:	4c 89 70 f8          	mov    %r14,-0x8(%rax)
   3b9b4:	48 89 83 80 01 01 00 	mov    %rax,0x10180(%rbx)

/* 	Run future->get(). Check for EXCEPTION (the ffff flag). Then next check whether
	the tuple is ready. Finally complete the stop() measurement, and return (local case).

   3b9bb:	49 8b 07             	mov    (%r15),%rax
   3b9be:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
   3b9c2:	0f 84 28 02 00 00    	je     3bbf0 <TupleFuture<benchmark::ycsb::YCSBTableInfo::KV>* TransactionBase<benchmark::ycsb::YCSB, benchmark::ycsb::YCSBArgs, benchmark::ycsb::YCSBTableInfo>::read<benchmark::ycsb::YCSBTableInfo::KV>(StructTable<benchmark::ycsb::YCSBTableInfo::KV>*, p4db::key_t)+0x3e0>
   3b9c8:	49 8b 07             	mov    (%r15),%rax
   3b9cb:	48 85 c0             	test   %rax,%rax
   3b9ce:	0f 84 2c 04 00 00    	je     3be00 <TupleFuture<benchmark::ycsb::YCSBTableInfo::KV>* TransactionBase<benchmark::ycsb::YCSB, benchmark::ycsb::YCSBArgs, benchmark::ycsb::YCSBTableInfo>::read<benchmark::ycsb::YCSBTableInfo::KV>(StructTable<benchmark::ycsb::YCSBTableInfo::KV>*, p4db::key_t)+0x5f0>
   3b9d4:	49 8b 07             	mov    (%r15),%rax
   3b9d7:	48 85 c0             	test   %rax,%rax
   3b9da:	0f 84 10 02 00 00    	je     3bbf0 <TupleFuture<benchmark::ycsb::YCSBTableInfo::KV>* TransactionBase<benchmark::ycsb::YCSB, benchmark::ycsb::YCSBArgs, benchmark::ycsb::YCSBTableInfo>::read<benchmark::ycsb::YCSBTableInfo::KV>(StructTable<benchmark::ycsb::YCSBTableInfo::KV>*, p4db::key_t)+0x3e0>
   3b9e0:	64 48 8b 0c 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rcx
   3b9e7:	ff ff 
   3b9e9:	0f 31                	rdtsc  
   3b9eb:	48 c1 e2 20          	shl    $0x20,%rdx
   3b9ef:	48 09 d0             	or     %rdx,%rax
   3b9f2:	48 03 81 78 01 00 00 	add    0x178(%rcx),%rax
   3b9f9:	48 2b 81 80 01 00 00 	sub    0x180(%rcx),%rax
   3ba00:	48 89 81 78 01 00 00 	mov    %rax,0x178(%rcx)
   3ba07:	e9 a8 01 00 00       	jmpq   3bbb4 <TupleFuture<benchmark::ycsb::YCSBTableInfo::KV>* TransactionBase<benchmark::ycsb::YCSB, benchmark::ycsb::YCSBArgs, benchmark::ycsb::YCSBTableInfo>::read<benchmark::ycsb::YCSBTableInfo::KV>(StructTable<benchmark::ycsb::YCSBTableInfo::KV>*, p4db::key_t)+0x3a4>

/*	Other code */

   3ba0c:	0f 1f 40 00          	nopl   0x0(%rax)
   3ba10:	0f 31                	rdtsc  
   3ba12:	48 c1 e2 20          	shl    $0x20,%rdx
   3ba16:	48 09 d0             	or     %rdx,%rax
   3ba19:	48 8b 97 68 01 00 00 	mov    0x168(%rdi),%rdx
   3ba20:	bf e0 05 00 00       	mov    $0x5e0,%edi
   3ba25:	48 89 81 68 01 00 00 	mov    %rax,0x168(%rcx)
   3ba2c:	4c 8b 6a 58          	mov    0x58(%rdx),%r13
   3ba30:	48 89 14 24          	mov    %rdx,(%rsp)
   3ba34:	e8 87 03 fd ff       	callq  bdc0 <malloc@plt>
   3ba39:	48 8b b3 a0 01 01 00 	mov    0x101a0(%rbx),%rsi
   3ba40:	f3 0f 7e 83 c0 21 01 	movq   0x121c0(%rbx),%xmm0
   3ba47:	00 
   3ba48:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
   3ba4d:	66 48 0f 3a 22 45 08 	pinsrq $0x1,0x8(%rbp),%xmm0
   3ba54:	01 
   3ba55:	c7 80 dc 05 00 00 30 	movl   $0x30,0x5dc(%rax)
   3ba5c:	00 00 00 
   3ba5f:	41 8b 4d 68          	mov    0x68(%r13),%ecx
   3ba63:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
   3ba69:	0f 11 40 10          	movups %xmm0,0x10(%rax)
   3ba6d:	4c 89 60 20          	mov    %r12,0x20(%rax)
   3ba71:	c7 40 28 01 00 00 00 	movl   $0x1,0x28(%rax)
   3ba78:	89 48 04             	mov    %ecx,0x4(%rax)
   3ba7b:	48 8d 4e 10          	lea    0x10(%rsi),%rcx
   3ba7f:	48 81 f9 00 20 00 00 	cmp    $0x2000,%rcx
   3ba86:	0f 87 4c 5e fd ff    	ja     118d8 <TupleFuture<benchmark::ycsb::YCSBTableInfo::KV>* TransactionBase<benchmark::ycsb::YCSB, benchmark::ycsb::YCSBArgs, benchmark::ycsb::YCSBTableInfo>::read<benchmark::ycsb::YCSBTableInfo::KV>(StructTable<benchmark::ycsb::YCSBTableInfo::KV>*, p4db::key_t) [clone .cold]+0x32>
   3ba8c:	48 8b 14 24          	mov    (%rsp),%rdx
   3ba90:	4c 8d ac 33 a8 01 01 	lea    0x101a8(%rbx,%rsi,1),%r13
   3ba97:	00 
   3ba98:	66 0f ef c0          	pxor   %xmm0,%xmm0
   3ba9c:	41 0f 11 45 00       	movups %xmm0,0x0(%r13)
   3baa1:	48 89 8b a0 01 01 00 	mov    %rcx,0x101a0(%rbx)
   3baa8:	b9 01 00 00 00       	mov    $0x1,%ecx
   3baad:	48 8b 52 50          	mov    0x50(%rdx),%rdx
   3bab1:	f0 48 0f c1 8a a0 00 	lock xadd %rcx,0xa0(%rdx)
   3bab8:	00 00 
   3baba:	48 89 48 08          	mov    %rcx,0x8(%rax)
   3babe:	48 8b 83 68 01 00 00 	mov    0x168(%rbx),%rax
   3bac5:	48 8b 50 50          	mov    0x50(%rax),%rdx
   3bac9:	48 89 c8             	mov    %rcx,%rax
   3bacc:	25 ff 03 00 00       	and    $0x3ff,%eax
   3bad1:	48 c1 e0 06          	shl    $0x6,%rax
   3bad5:	48 8d 94 02 a8 00 00 	lea    0xa8(%rdx,%rax,1),%rdx
   3badc:	00 
   3badd:	31 c0                	xor    %eax,%eax
   3badf:	f0 4c 0f b1 6a 08    	lock cmpxchg %r13,0x8(%rdx)
   3bae5:	0f 94 c0             	sete   %al
   3bae8:	0f b6 c0             	movzbl %al,%eax
   3baeb:	0f 85 2b 03 00 00    	jne    3be1c <TupleFuture<benchmark::ycsb::YCSBTableInfo::KV>* TransactionBase<benchmark::ycsb::YCSB, benchmark::ycsb::YCSBArgs, benchmark::ycsb::YCSBTableInfo>::read<benchmark::ycsb::YCSBTableInfo::KV>(StructTable<benchmark::ycsb::YCSBTableInfo::KV>*, p4db::key_t)+0x60c>
   3baf1:	48 8b 83 68 01 00 00 	mov    0x168(%rbx),%rax
   3baf8:	48 89 0a             	mov    %rcx,(%rdx)
   3bafb:	44 89 fe             	mov    %r15d,%esi
   3bafe:	48 8d 54 24 30       	lea    0x30(%rsp),%rdx
   3bb03:	48 8b 78 58          	mov    0x58(%rax),%rdi
   3bb07:	e8 84 84 02 00       	callq  63f90 <UDPCommunicator::send(msg::node_t, UDPPacketBuffer*&)>
   3bb0c:	48 8b 93 70 01 00 00 	mov    0x170(%rbx),%rdx
   3bb13:	48 8d 42 18          	lea    0x18(%rdx),%rax
   3bb17:	48 3d 00 00 01 00    	cmp    $0x10000,%rax
   3bb1d:	0f 87 9d 03 00 00    	ja     3bec0 <TupleFuture<benchmark::ycsb::YCSBTableInfo::KV>* TransactionBase<benchmark::ycsb::YCSB, benchmark::ycsb::YCSBArgs, benchmark::ycsb::YCSBTableInfo>::read<benchmark::ycsb::YCSBTableInfo::KV>(StructTable<benchmark::ycsb::YCSBTableInfo::KV>*, p4db::key_t)+0x6b0>
   3bb23:	48 8d ac 13 78 01 00 	lea    0x178(%rbx,%rdx,1),%rbp
   3bb2a:	00 
   3bb2b:	4c 8b a3 88 01 01 00 	mov    0x10188(%rbx),%r12
   3bb32:	48 8d 35 2f 7e 04 00 	lea    0x47e2f(%rip),%rsi        # 83968 <vtable for Remote<benchmark::ycsb::YCSBTableInfo::KV, AccessMode{1u}>+0x10>
   3bb39:	4c 89 6d 08          	mov    %r13,0x8(%rbp)
   3bb3d:	48 89 75 00          	mov    %rsi,0x0(%rbp)
   3bb41:	44 89 75 10          	mov    %r14d,0x10(%rbp)
   3bb45:	48 89 83 70 01 00 00 	mov    %rax,0x170(%rbx)
   3bb4c:	48 8b 83 80 01 01 00 	mov    0x10180(%rbx),%rax
   3bb53:	4c 39 e0             	cmp    %r12,%rax
   3bb56:	0f 84 9c 00 00 00    	je     3bbf8 <TupleFuture<benchmark::ycsb::YCSBTableInfo::KV>* TransactionBase<benchmark::ycsb::YCSB, benchmark::ycsb::YCSBArgs, benchmark::ycsb::YCSBTableInfo>::read<benchmark::ycsb::YCSBTableInfo::KV>(StructTable<benchmark::ycsb::YCSBTableInfo::KV>*, p4db::key_t)+0x3e8>
   3bb5c:	48 89 28             	mov    %rbp,(%rax)
   3bb5f:	48 83 c0 08          	add    $0x8,%rax
   3bb63:	48 89 83 80 01 01 00 	mov    %rax,0x10180(%rbx)
   3bb6a:	49 8d 45 08          	lea    0x8(%r13),%rax
   3bb6e:	49 8b 55 08          	mov    0x8(%r13),%rdx
   3bb72:	48 83 fa ff          	cmp    $0xffffffffffffffff,%rdx
   3bb76:	74 78                	je     3bbf0 <TupleFuture<benchmark::ycsb::YCSBTableInfo::KV>* TransactionBase<benchmark::ycsb::YCSB, benchmark::ycsb::YCSBArgs, benchmark::ycsb::YCSBTableInfo>::read<benchmark::ycsb::YCSBTableInfo::KV>(StructTable<benchmark::ycsb::YCSBTableInfo::KV>*, p4db::key_t)+0x3e0>
   3bb78:	49 8b 55 08          	mov    0x8(%r13),%rdx
   3bb7c:	48 85 d2             	test   %rdx,%rdx
   3bb7f:	0f 84 3b 02 00 00    	je     3bdc0 <TupleFuture<benchmark::ycsb::YCSBTableInfo::KV>* TransactionBase<benchmark::ycsb::YCSB, benchmark::ycsb::YCSBArgs, benchmark::ycsb::YCSBTableInfo>::read<benchmark::ycsb::YCSBTableInfo::KV>(StructTable<benchmark::ycsb::YCSBTableInfo::KV>*, p4db::key_t)+0x5b0>
   3bb85:	48 8b 00             	mov    (%rax),%rax
   3bb88:	48 85 c0             	test   %rax,%rax
   3bb8b:	74 63                	je     3bbf0 <TupleFuture<benchmark::ycsb::YCSBTableInfo::KV>* TransactionBase<benchmark::ycsb::YCSB, benchmark::ycsb::YCSBArgs, benchmark::ycsb::YCSBTableInfo>::read<benchmark::ycsb::YCSBTableInfo::KV>(StructTable<benchmark::ycsb::YCSBTableInfo::KV>*, p4db::key_t)+0x3e0>
   3bb8d:	64 48 8b 0c 25 f8 ff 	mov    %fs:0xfffffffffffffff8,%rcx
   3bb94:	ff ff 
   3bb96:	0f 31                	rdtsc  
   3bb98:	48 c1 e2 20          	shl    $0x20,%rdx
   3bb9c:	48 09 d0             	or     %rdx,%rax
   3bb9f:	48 03 81 60 01 00 00 	add    0x160(%rcx),%rax
   3bba6:	48 2b 81 68 01 00 00 	sub    0x168(%rcx),%rax
   3bbad:	48 89 81 60 01 00 00 	mov    %rax,0x160(%rcx)

/*	Stack canary check- compare the canary with the process canary, if ok, done */

   3bbb4:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
   3bbb9:	64 48 2b 04 25 28 00 	sub    %fs:0x28,%rax
   3bbc0:	00 00 
   3bbc2:	0f 85 c2 02 00 00    	jne    3be8a <TupleFuture<benchmark::ycsb::YCSBTableInfo::KV>* TransactionBase<benchmark::ycsb::YCSB, benchmark::ycsb::YCSBArgs, benchmark::ycsb::YCSBTableInfo>::read<benchmark::ycsb::YCSBTableInfo::KV>(StructTable<benchmark::ycsb::YCSBTableInfo::KV>*, p4db::key_t)+0x67a>
   3bbc8:	48 83 c4 48          	add    $0x48,%rsp
   3bbcc:	4c 89 e8             	mov    %r13,%rax
   3bbcf:	5b                   	pop    %rbx
   3bbd0:	5d                   	pop    %rbp
   3bbd1:	41 5c                	pop    %r12
   3bbd3:	41 5d                	pop    %r13
   3bbd5:	41 5e                	pop    %r14
   3bbd7:	41 5f                	pop    %r15
   3bbd9:	c3                   	retq   
   3bbda:	48 c7 c2 ff ff ff ff 	mov    $0xffffffffffffffff,%rdx
   3bbe1:	48 87 10             	xchg   %rdx,(%rax)
   3bbe4:	e8 47 01 fd ff       	callq  bd30 <free@plt>
   3bbe9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
   3bbf0:	45 31 ed             	xor    %r13d,%r13d
   3bbf3:	eb bf                	jmp    3bbb4 <TupleFuture<benchmark::ycsb::YCSBTableInfo::KV>* TransactionBase<benchmark::ycsb::YCSB, benchmark::ycsb::YCSBArgs, benchmark::ycsb::YCSBTableInfo>::read<benchmark::ycsb::YCSBTableInfo::KV>(StructTable<benchmark::ycsb::YCSBTableInfo::KV>*, p4db::key_t)+0x3a4>
   3bbf5:	0f 1f 00             	nopl   (%rax)
   3bbf8:	4c 8b bb 78 01 01 00 	mov    0x10178(%rbx),%r15
   3bbff:	4c 89 e6             	mov    %r12,%rsi
   3bc02:	45 31 f6             	xor    %r14d,%r14d
   3bc05:	4c 89 ff             	mov    %r15,%rdi
   3bc08:	e8 d3 df 02 00       	callq  69be0 <std::vector<Action*, std::allocator<Action*> >::_M_check_len(unsigned long, char const*) const [clone .constprop.0] [clone .isra.0]>
   3bc0d:	4c 89 e2             	mov    %r12,%rdx
   3bc10:	48 89 c1             	mov    %rax,%rcx
   3bc13:	4c 29 fa             	sub    %r15,%rdx
   3bc16:	48 85 c0             	test   %rax,%rax
   3bc19:	74 24                	je     3bc3f <TupleFuture<benchmark::ycsb::YCSBTableInfo::KV>* TransactionBase<benchmark::ycsb::YCSB, benchmark::ycsb::YCSBArgs, benchmark::ycsb::YCSBTableInfo>::read<benchmark::ycsb::YCSBTableInfo::KV>(StructTable<benchmark::ycsb::YCSBTableInfo::KV>*, p4db::key_t)+0x42f>
   3bc1b:	48 89 c7             	mov    %rax,%rdi
   3bc1e:	48 89 54 24 10       	mov    %rdx,0x10(%rsp)
   3bc23:	48 89 04 24          	mov    %rax,(%rsp)
   3bc27:	e8 24 83 02 00       	callq  63f50 <__gnu_cxx::new_allocator<std::__detail::_Hash_node_base*>::allocate(unsigned long, void const*) [clone .constprop.1]>
   3bc2c:	4c 8b a3 88 01 01 00 	mov    0x10188(%rbx),%r12
   3bc33:	48 8b 54 24 10       	mov    0x10(%rsp),%rdx
   3bc38:	49 89 c6             	mov    %rax,%r14
   3bc3b:	48 8b 0c 24          	mov    (%rsp),%rcx
   3bc3f:	49 8d 44 16 08       	lea    0x8(%r14,%rdx,1),%rax
   3bc44:	66 49 0f 6e c6       	movq   %r14,%xmm0
   3bc49:	49 89 2c 16          	mov    %rbp,(%r14,%rdx,1)
   3bc4d:	66 48 0f 3a 22 c0 01 	pinsrq $0x1,%rax,%xmm0
   3bc54:	48 85 d2             	test   %rdx,%rdx
   3bc57:	0f 8f 03 01 00 00    	jg     3bd60 <TupleFuture<benchmark::ycsb::YCSBTableInfo::KV>* TransactionBase<benchmark::ycsb::YCSB, benchmark::ycsb::YCSBArgs, benchmark::ycsb::YCSBTableInfo>::read<benchmark::ycsb::YCSBTableInfo::KV>(StructTable<benchmark::ycsb::YCSBTableInfo::KV>*, p4db::key_t)+0x550>
   3bc5d:	4d 85 ff             	test   %r15,%r15
   3bc60:	0f 85 18 01 00 00    	jne    3bd7e <TupleFuture<benchmark::ycsb::YCSBTableInfo::KV>* TransactionBase<benchmark::ycsb::YCSB, benchmark::ycsb::YCSBArgs, benchmark::ycsb::YCSBTableInfo>::read<benchmark::ycsb::YCSBTableInfo::KV>(StructTable<benchmark::ycsb::YCSBTableInfo::KV>*, p4db::key_t)+0x56e>
   3bc66:	49 8d 04 ce          	lea    (%r14,%rcx,8),%rax
   3bc6a:	0f 11 83 78 01 01 00 	movups %xmm0,0x10178(%rbx)
   3bc71:	48 89 83 88 01 01 00 	mov    %rax,0x10188(%rbx)
   3bc78:	e9 ed fe ff ff       	jmpq   3bb6a <TupleFuture<benchmark::ycsb::YCSBTableInfo::KV>* TransactionBase<benchmark::ycsb::YCSB, benchmark::ycsb::YCSBArgs, benchmark::ycsb::YCSBTableInfo>::read<benchmark::ycsb::YCSBTableInfo::KV>(StructTable<benchmark::ycsb::YCSBTableInfo::KV>*, p4db::key_t)+0x35a>
   3bc7d:	0f 1f 00             	nopl   (%rax)
   3bc80:	4c 8b 83 78 01 01 00 	mov    0x10178(%rbx),%r8
   3bc87:	48 89 ee             	mov    %rbp,%rsi
   3bc8a:	45 31 e4             	xor    %r12d,%r12d
   3bc8d:	4c 89 c7             	mov    %r8,%rdi
   3bc90:	4c 89 04 24          	mov    %r8,(%rsp)
   3bc94:	e8 47 df 02 00       	callq  69be0 <std::vector<Action*, std::allocator<Action*> >::_M_check_len(unsigned long, char const*) const [clone .constprop.0] [clone .isra.0]>
   3bc99:	4c 8b 04 24          	mov    (%rsp),%r8
   3bc9d:	48 89 ea             	mov    %rbp,%rdx
   3bca0:	48 89 c1             	mov    %rax,%rcx
   3bca3:	4c 29 c2             	sub    %r8,%rdx
   3bca6:	48 85 c0             	test   %rax,%rax
   3bca9:	74 2e                	je     3bcd9 <TupleFuture<benchmark::ycsb::YCSBTableInfo::KV>* TransactionBase<benchmark::ycsb::YCSB, benchmark::ycsb::YCSBArgs, benchmark::ycsb::YCSBTableInfo>::read<benchmark::ycsb::YCSBTableInfo::KV>(StructTable<benchmark::ycsb::YCSBTableInfo::KV>*, p4db::key_t)+0x4c9>
   3bcab:	48 89 c7             	mov    %rax,%rdi
   3bcae:	4c 89 44 24 28       	mov    %r8,0x28(%rsp)
   3bcb3:	48 89 54 24 10       	mov    %rdx,0x10(%rsp)
   3bcb8:	48 89 04 24          	mov    %rax,(%rsp)
   3bcbc:	e8 8f 82 02 00       	callq  63f50 <__gnu_cxx::new_allocator<std::__detail::_Hash_node_base*>::allocate(unsigned long, void const*) [clone .constprop.1]>
   3bcc1:	48 8b ab 88 01 01 00 	mov    0x10188(%rbx),%rbp
   3bcc8:	4c 8b 44 24 28       	mov    0x28(%rsp),%r8
   3bccd:	49 89 c4             	mov    %rax,%r12
   3bcd0:	48 8b 54 24 10       	mov    0x10(%rsp),%rdx
   3bcd5:	48 8b 0c 24          	mov    (%rsp),%rcx
   3bcd9:	49 8d 44 14 08       	lea    0x8(%r12,%rdx,1),%rax
   3bcde:	66 49 0f 6e c4       	movq   %r12,%xmm0
   3bce3:	4d 89 34 14          	mov    %r14,(%r12,%rdx,1)
   3bce7:	66 48 0f 3a 22 c0 01 	pinsrq $0x1,%rax,%xmm0
   3bcee:	48 85 d2             	test   %rdx,%rdx
   3bcf1:	7f 1d                	jg     3bd10 <TupleFuture<benchmark::ycsb::YCSBTableInfo::KV>* TransactionBase<benchmark::ycsb::YCSB, benchmark::ycsb::YCSBArgs, benchmark::ycsb::YCSBTableInfo>::read<benchmark::ycsb::YCSBTableInfo::KV>(StructTable<benchmark::ycsb::YCSBTableInfo::KV>*, p4db::key_t)+0x500>
   3bcf3:	4d 85 c0             	test   %r8,%r8
   3bcf6:	75 40                	jne    3bd38 <TupleFuture<benchmark::ycsb::YCSBTableInfo::KV>* TransactionBase<benchmark::ycsb::YCSB, benchmark::ycsb::YCSBArgs, benchmark::ycsb::YCSBTableInfo>::read<benchmark::ycsb::YCSBTableInfo::KV>(StructTable<benchmark::ycsb::YCSBTableInfo::KV>*, p4db::key_t)+0x528>
   3bcf8:	49 8d 04 cc          	lea    (%r12,%rcx,8),%rax
   3bcfc:	0f 11 83 78 01 01 00 	movups %xmm0,0x10178(%rbx)
   3bd03:	48 89 83 88 01 01 00 	mov    %rax,0x10188(%rbx)
   3bd0a:	e9 ac fc ff ff       	jmpq   3b9bb <TupleFuture<benchmark::ycsb::YCSBTableInfo::KV>* TransactionBase<benchmark::ycsb::YCSB, benchmark::ycsb::YCSBArgs, benchmark::ycsb::YCSBTableInfo>::read<benchmark::ycsb::YCSBTableInfo::KV>(StructTable<benchmark::ycsb::YCSBTableInfo::KV>*, p4db::key_t)+0x1ab>
   3bd0f:	90                   	nop
   3bd10:	4c 89 c6             	mov    %r8,%rsi
   3bd13:	4c 89 e7             	mov    %r12,%rdi
   3bd16:	48 89 4c 24 28       	mov    %rcx,0x28(%rsp)
   3bd1b:	0f 29 44 24 10       	movaps %xmm0,0x10(%rsp)
   3bd20:	4c 89 04 24          	mov    %r8,(%rsp)
   3bd24:	e8 d7 01 fd ff       	callq  bf00 <memmove@plt>
   3bd29:	48 8b 4c 24 28       	mov    0x28(%rsp),%rcx
   3bd2e:	4c 8b 04 24          	mov    (%rsp),%r8
   3bd32:	66 0f 6f 44 24 10    	movdqa 0x10(%rsp),%xmm0
   3bd38:	48 89 ee             	mov    %rbp,%rsi
   3bd3b:	4c 89 c7             	mov    %r8,%rdi
   3bd3e:	48 89 4c 24 10       	mov    %rcx,0x10(%rsp)
   3bd43:	4c 29 c6             	sub    %r8,%rsi
   3bd46:	0f 29 04 24          	movaps %xmm0,(%rsp)
   3bd4a:	e8 11 ff fc ff       	callq  bc60 <operator delete(void*, unsigned long)@plt>
   3bd4f:	48 8b 4c 24 10       	mov    0x10(%rsp),%rcx
   3bd54:	66 0f 6f 04 24       	movdqa (%rsp),%xmm0
   3bd59:	eb 9d                	jmp    3bcf8 <TupleFuture<benchmark::ycsb::YCSBTableInfo::KV>* TransactionBase<benchmark::ycsb::YCSB, benchmark::ycsb::YCSBArgs, benchmark::ycsb::YCSBTableInfo>::read<benchmark::ycsb::YCSBTableInfo::KV>(StructTable<benchmark::ycsb::YCSBTableInfo::KV>*, p4db::key_t)+0x4e8>
   3bd5b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
   3bd60:	4c 89 fe             	mov    %r15,%rsi
   3bd63:	4c 89 f7             	mov    %r14,%rdi
   3bd66:	0f 29 44 24 10       	movaps %xmm0,0x10(%rsp)
   3bd6b:	48 89 0c 24          	mov    %rcx,(%rsp)
   3bd6f:	e8 8c 01 fd ff       	callq  bf00 <memmove@plt>
   3bd74:	48 8b 0c 24          	mov    (%rsp),%rcx
   3bd78:	66 0f 6f 44 24 10    	movdqa 0x10(%rsp),%xmm0
   3bd7e:	4c 89 e6             	mov    %r12,%rsi
   3bd81:	4c 89 ff             	mov    %r15,%rdi
   3bd84:	0f 29 44 24 10       	movaps %xmm0,0x10(%rsp)
   3bd89:	4c 29 fe             	sub    %r15,%rsi
   3bd8c:	48 89 0c 24          	mov    %rcx,(%rsp)
   3bd90:	e8 cb fe fc ff       	callq  bc60 <operator delete(void*, unsigned long)@plt>
   3bd95:	48 8b 0c 24          	mov    (%rsp),%rcx
   3bd99:	66 0f 6f 44 24 10    	movdqa 0x10(%rsp),%xmm0
   3bd9f:	e9 c2 fe ff ff       	jmpq   3bc66 <TupleFuture<benchmark::ycsb::YCSBTableInfo::KV>* TransactionBase<benchmark::ycsb::YCSB, benchmark::ycsb::YCSBArgs, benchmark::ycsb::YCSBTableInfo>::read<benchmark::ycsb::YCSBTableInfo::KV>(StructTable<benchmark::ycsb::YCSBTableInfo::KV>*, p4db::key_t)+0x456>
   3bda4:	48 8b 10             	mov    (%rax),%rdx
   3bda7:	48 83 fa ff          	cmp    $0xffffffffffffffff,%rdx
   3bdab:	0f 84 3f fe ff ff    	je     3bbf0 <TupleFuture<benchmark::ycsb::YCSBTableInfo::KV>* TransactionBase<benchmark::ycsb::YCSB, benchmark::ycsb::YCSBArgs, benchmark::ycsb::YCSBTableInfo>::read<benchmark::ycsb::YCSBTableInfo::KV>(StructTable<benchmark::ycsb::YCSBTableInfo::KV>*, p4db::key_t)+0x3e0>
   3bdb1:	48 8b 10             	mov    (%rax),%rdx
   3bdb4:	48 85 d2             	test   %rdx,%rdx
   3bdb7:	0f 85 c8 fd ff ff    	jne    3bb85 <TupleFuture<benchmark::ycsb::YCSBTableInfo::KV>* TransactionBase<benchmark::ycsb::YCSB, benchmark::ycsb::YCSBArgs, benchmark::ycsb::YCSBTableInfo>::read<benchmark::ycsb::YCSBTableInfo::KV>(StructTable<benchmark::ycsb::YCSBTableInfo::KV>*, p4db::key_t)+0x375>
   3bdbd:	f3 90                	pause  
   3bdbf:	90                   	nop
   3bdc0:	49 8b 7d 00          	mov    0x0(%r13),%rdi
   3bdc4:	48 85 ff             	test   %rdi,%rdi
   3bdc7:	74 db                	je     3bda4 <TupleFuture<benchmark::ycsb::YCSBTableInfo::KV>* TransactionBase<benchmark::ycsb::YCSB, benchmark::ycsb::YCSBArgs, benchmark::ycsb::YCSBTableInfo>::read<benchmark::ycsb::YCSBTableInfo::KV>(StructTable<benchmark::ycsb::YCSBTableInfo::KV>*, p4db::key_t)+0x594>
   3bdc9:	8b 57 28             	mov    0x28(%rdi),%edx
   3bdcc:	85 d2                	test   %edx,%edx
   3bdce:	0f 84 06 fe ff ff    	je     3bbda <TupleFuture<benchmark::ycsb::YCSBTableInfo::KV>* TransactionBase<benchmark::ycsb::YCSB, benchmark::ycsb::YCSBArgs, benchmark::ycsb::YCSBTableInfo>::read<benchmark::ycsb::YCSBTableInfo::KV>(StructTable<benchmark::ycsb::YCSBTableInfo::KV>*, p4db::key_t)+0x3ca>
   3bdd4:	48 83 c7 2c          	add    $0x2c,%rdi
   3bdd8:	48 87 38             	xchg   %rdi,(%rax)
   3bddb:	e9 a5 fd ff ff       	jmpq   3bb85 <TupleFuture<benchmark::ycsb::YCSBTableInfo::KV>* TransactionBase<benchmark::ycsb::YCSB, benchmark::ycsb::YCSBArgs, benchmark::ycsb::YCSBTableInfo>::read<benchmark::ycsb::YCSBTableInfo::KV>(StructTable<benchmark::ycsb::YCSBTableInfo::KV>*, p4db::key_t)+0x375>
   3bde0:	49 8b 07             	mov    (%r15),%rax
   3bde3:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
   3bde7:	0f 84 03 fe ff ff    	je     3bbf0 <TupleFuture<benchmark::ycsb::YCSBTableInfo::KV>* TransactionBase<benchmark::ycsb::YCSB, benchmark::ycsb::YCSBArgs, benchmark::ycsb::YCSBTableInfo>::read<benchmark::ycsb::YCSBTableInfo::KV>(StructTable<benchmark::ycsb::YCSBTableInfo::KV>*, p4db::key_t)+0x3e0>
   3bded:	49 8b 07             	mov    (%r15),%rax
   3bdf0:	48 85 c0             	test   %rax,%rax
   3bdf3:	0f 85 db fb ff ff    	jne    3b9d4 <TupleFuture<benchmark::ycsb::YCSBTableInfo::KV>* TransactionBase<benchmark::ycsb::YCSB, benchmark::ycsb::YCSBArgs, benchmark::ycsb::YCSBTableInfo>::read<benchmark::ycsb::YCSBTableInfo::KV>(StructTable<benchmark::ycsb::YCSBTableInfo::KV>*, p4db::key_t)+0x1c4>
   3bdf9:	f3 90                	pause  
   3bdfb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
   3be00:	49 8b 7d 00          	mov    0x0(%r13),%rdi
   3be04:	48 85 ff             	test   %rdi,%rdi
   3be07:	74 d7                	je     3bde0 <TupleFuture<benchmark::ycsb::YCSBTableInfo::KV>* TransactionBase<benchmark::ycsb::YCSB, benchmark::ycsb::YCSBArgs, benchmark::ycsb::YCSBTableInfo>::read<benchmark::ycsb::YCSBTableInfo::KV>(StructTable<benchmark::ycsb::YCSBTableInfo::KV>*, p4db::key_t)+0x5d0>
   3be09:	8b 4f 28             	mov    0x28(%rdi),%ecx
   3be0c:	85 c9                	test   %ecx,%ecx
   3be0e:	74 63                	je     3be73 <TupleFuture<benchmark::ycsb::YCSBTableInfo::KV>* TransactionBase<benchmark::ycsb::YCSB, benchmark::ycsb::YCSBArgs, benchmark::ycsb::YCSBTableInfo>::read<benchmark::ycsb::YCSBTableInfo::KV>(StructTable<benchmark::ycsb::YCSBTableInfo::KV>*, p4db::key_t)+0x663>
   3be10:	48 83 c7 2c          	add    $0x2c,%rdi
   3be14:	49 87 3f             	xchg   %rdi,(%r15)
   3be17:	e9 b8 fb ff ff       	jmpq   3b9d4 <TupleFuture<benchmark::ycsb::YCSBTableInfo::KV>* TransactionBase<benchmark::ycsb::YCSB, benchmark::ycsb::YCSBArgs, benchmark::ycsb::YCSBTableInfo>::read<benchmark::ycsb::YCSBTableInfo::KV>(StructTable<benchmark::ycsb::YCSBTableInfo::KV>*, p4db::key_t)+0x1c4>
   3be1c:	48 8d 72 10          	lea    0x10(%rdx),%rsi
   3be20:	f0 4c 0f b1 6a 18    	lock cmpxchg %r13,0x18(%rdx)
   3be26:	0f 94 c0             	sete   %al
   3be29:	0f b6 c0             	movzbl %al,%eax
   3be2c:	75 68                	jne    3be96 <TupleFuture<benchmark::ycsb::YCSBTableInfo::KV>* TransactionBase<benchmark::ycsb::YCSB, benchmark::ycsb::YCSBArgs, benchmark::ycsb::YCSBTableInfo>::read<benchmark::ycsb::YCSBTableInfo::KV>(StructTable<benchmark::ycsb::YCSBTableInfo::KV>*, p4db::key_t)+0x686>
   3be2e:	48 89 f2             	mov    %rsi,%rdx
   3be31:	e9 bb fc ff ff       	jmpq   3baf1 <TupleFuture<benchmark::ycsb::YCSBTableInfo::KV>* TransactionBase<benchmark::ycsb::YCSB, benchmark::ycsb::YCSBArgs, benchmark::ycsb::YCSBTableInfo>::read<benchmark::ycsb::YCSBTableInfo::KV>(StructTable<benchmark::ycsb::YCSBTableInfo::KV>*, p4db::key_t)+0x2e1>
   3be36:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
   3be3d:	00 00 00 
   3be40:	48 83 41 08 01       	addq   $0x1,0x8(%rcx)
   3be45:	45 31 ed             	xor    %r13d,%r13d
   3be48:	e9 67 fd ff ff       	jmpq   3bbb4 <TupleFuture<benchmark::ycsb::YCSBTableInfo::KV>* TransactionBase<benchmark::ycsb::YCSB, benchmark::ycsb::YCSBArgs, benchmark::ycsb::YCSBTableInfo>::read<benchmark::ycsb::YCSBTableInfo::KV>(StructTable<benchmark::ycsb::YCSBTableInfo::KV>*, p4db::key_t)+0x3a4>
   3be4d:	0f 1f 00             	nopl   (%rax)
   3be50:	48 83 41 08 01       	addq   $0x1,0x8(%rcx)
   3be55:	45 31 ed             	xor    %r13d,%r13d
   3be58:	48 83 3d 10 a1 04 00 	cmpq   $0x0,0x4a110(%rip)        # 85f70 <__pthread_key_create@GLIBC_2.2.5>
   3be5f:	00 
   3be60:	0f 84 4e fd ff ff    	je     3bbb4 <TupleFuture<benchmark::ycsb::YCSBTableInfo::KV>* TransactionBase<benchmark::ycsb::YCSB, benchmark::ycsb::YCSBArgs, benchmark::ycsb::YCSBTableInfo>::read<benchmark::ycsb::YCSBTableInfo::KV>(StructTable<benchmark::ycsb::YCSBTableInfo::KV>*, p4db::key_t)+0x3a4>
   3be66:	4c 89 f7             	mov    %r14,%rdi
   3be69:	e8 e2 fc fc ff       	callq  bb50 <pthread_mutex_unlock@plt>
   3be6e:	e9 41 fd ff ff       	jmpq   3bbb4 <TupleFuture<benchmark::ycsb::YCSBTableInfo::KV>* TransactionBase<benchmark::ycsb::YCSB, benchmark::ycsb::YCSBArgs, benchmark::ycsb::YCSBTableInfo>::read<benchmark::ycsb::YCSBTableInfo::KV>(StructTable<benchmark::ycsb::YCSBTableInfo::KV>*, p4db::key_t)+0x3a4>
   3be73:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
   3be7a:	49 87 07             	xchg   %rax,(%r15)
   3be7d:	45 31 ed             	xor    %r13d,%r13d
   3be80:	e8 ab fe fc ff       	callq  bd30 <free@plt>
   3be85:	e9 2a fd ff ff       	jmpq   3bbb4 <TupleFuture<benchmark::ycsb::YCSBTableInfo::KV>* TransactionBase<benchmark::ycsb::YCSB, benchmark::ycsb::YCSBArgs, benchmark::ycsb::YCSBTableInfo>::read<benchmark::ycsb::YCSBTableInfo::KV>(StructTable<benchmark::ycsb::YCSBTableInfo::KV>*, p4db::key_t)+0x3a4>
   3be8a:	e8 41 fe fc ff       	callq  bcd0 <__stack_chk_fail@plt>
   3be8f:	89 c7                	mov    %eax,%edi
   3be91:	e8 2a fc fc ff       	callq  bac0 <std::__throw_system_error(int)@plt>
   3be96:	48 8d 72 20          	lea    0x20(%rdx),%rsi
   3be9a:	f0 4c 0f b1 6a 28    	lock cmpxchg %r13,0x28(%rdx)
   3bea0:	0f 94 c0             	sete   %al
   3bea3:	0f b6 c0             	movzbl %al,%eax
   3bea6:	74 86                	je     3be2e <TupleFuture<benchmark::ycsb::YCSBTableInfo::KV>* TransactionBase<benchmark::ycsb::YCSB, benchmark::ycsb::YCSBArgs, benchmark::ycsb::YCSBTableInfo>::read<benchmark::ycsb::YCSBTableInfo::KV>(StructTable<benchmark::ycsb::YCSBTableInfo::KV>*, p4db::key_t)+0x61e>
   3bea8:	48 8d 72 30          	lea    0x30(%rdx),%rsi
   3beac:	f0 4c 0f b1 6a 38    	lock cmpxchg %r13,0x38(%rdx)
   3beb2:	48 89 f2             	mov    %rsi,%rdx
   3beb5:	0f 84 36 fc ff ff    	je     3baf1 <TupleFuture<benchmark::ycsb::YCSBTableInfo::KV>* TransactionBase<benchmark::ycsb::YCSB, benchmark::ycsb::YCSBArgs, benchmark::ycsb::YCSBTableInfo>::read<benchmark::ycsb::YCSBTableInfo::KV>(StructTable<benchmark::ycsb::YCSBTableInfo::KV>*, p4db::key_t)+0x2e1>
   3bebb:	e9 0a 5b fd ff       	jmpq   119ca <TupleFuture<benchmark::ycsb::YCSBTableInfo::KV>* TransactionBase<benchmark::ycsb::YCSB, benchmark::ycsb::YCSBArgs, benchmark::ycsb::YCSBTableInfo>::read<benchmark::ycsb::YCSBTableInfo::KV>(StructTable<benchmark::ycsb::YCSBTableInfo::KV>*, p4db::key_t) [clone .cold]+0x124>
   3bec0:	e9 8e 5a fd ff       	jmpq   11953 <TupleFuture<benchmark::ycsb::YCSBTableInfo::KV>* TransactionBase<benchmark::ycsb::YCSB, benchmark::ycsb::YCSBArgs, benchmark::ycsb::YCSBTableInfo>::read<benchmark::ycsb::YCSBTableInfo::KV>(StructTable<benchmark::ycsb::YCSBTableInfo::KV>*, p4db::key_t) [clone .cold]+0xad>
   3bec5:	90                   	nop
   3bec6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
   3becd:	00 00 00 
